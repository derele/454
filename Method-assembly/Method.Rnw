%%% Method.Rnw --- 

%% Author: emanuelheitlinger@gmail.com

\documentclass[12pt,a4paper]{article}
\usepackage[debugshow,final]{graphics}
\usepackage{hyperref}
\usepackage{float}
\usepackage{lscape} 
\usepackage{rotating} 
 

\date{}
\begin{document}
% make the plots modest size
\title{The transcriptome of A.crassus: Evaluating a method of combining assemblies}
\author{Emanuel Heitlinger}

\maketitle

<<load, echo=FALSE, results=hide>>=
library(lattice)
library(ggplot2)
library(MASS)
library(xtable)
library(reshape)

## library(Design)
library(limma)
library(VennDiagram)
source("/home/ele/thesis/454/common_R_functions.R")
@ 

<<functions_read, echo=FALSE, cache=TRUE>>=

mean.qual <- function(q){
  lapply(q, function(x) {w <- unlist(strsplit(x, " "))
                                    mean(as.numeric(w[nchar(w)>0]))})
}

raw.fasta <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_in.454.fasta")

raw.qual <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_in.454.fasta.qual")

qualmeans <- mean.qual(raw.qual)

ids <- substr(names(raw.fasta),1, 14)
seqlength <- nchar(raw.fasta)

RAW <- as.data.frame(cbind(ids=as.character(ids),
                           qualmeans=as.numeric(qualmeans),
                           seqlength=as.numeric(seqlength)))

nFLX <- length(grep("^F.*",perl=T,names(raw.fasta),value=T))
nTIT <- length(grep("^G.*",perl=T,names(raw.fasta), value=T))

## raw.fasta contains all trimmed bases in lower-case
trimmed.fasta <- gsub("[a-z]", "", raw.fasta)
nBases <- sum(nchar(trimmed.fasta))

trimmed.qual <- list()
for (l in (c("10F", "179F", "M175", "L2R3", "KS4F", "UW07F"))){
  command <- paste("/home/ele/tools/Newbler2.6/bin/sffinfo -q /home/ele/Data/454/pre_assembly_screening/final.", l, ".sff.trimmed.sff;", sep="")
  connect <- pipe(command)
  trimmed.qual[l] <- list(read.sequences(connect))
  closeAllConnections()
}

trimmed.qual <- unlist(trimmed.qual)
names(trimmed.qual) <- gsub(" .*$", "", names(trimmed.qual))
names(trimmed.qual) <- gsub("^.*\\.", "", names(trimmed.qual))

@ 

\section{Overview}
\label{sec:overview}

The pre-processed \textit{A. crassus} data-set consisting of
\Sexpr{nBases} bases in \Sexpr{length(raw.fasta)} reads (\Sexpr{nFLX}
generated using ``FLX-chemistry'', \Sexpr{nTIT} using
``Titanium-chemistry'') was assembled following an approach proposed
by \cite{pmid20950480}: two assemblies were generated, one using
Newbler v2.6 \cite{pmid16056220}, the other using Mira v3.2.1
\cite{miraEST}. The resulting assemblies (referred to as first-order
assemblies) were merged with Cap3 \cite{Cap3_Huang} into a combined
assembly (referred to as second-order assembly).

<<mirace, cache=TRUE, echo=FALSE>>=

read.ace <- function (path){
  command <- paste("perl -ne '$c =  $1 if /^CO (\\S+)/;",
                   "print \"$c $1\\n\"if /^AF (\\w+)(\\|*|\\.*)/'",
                   path)                    # last bit to get rid of
                                            # newblers .info and my
                                            # own |readcount
#  closeAllConnections()
  ace <- read.table(pipe(command), sep=" ")
  names(ace) <- c("contig", "read")
  return(ace)
}

MIR <- read.ace("/home/ele/Data/454/assemblies/mira/Acrassus_assembly/Acrassus_d_results/Acrassus_out.ace")
CMira <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_assembly/Acrassus_d_results/Acrassus_out.unpadded.fasta")
Miracontig.names <- names(CMira)
@

\section{The Newbler first-order assembly}
\label{sec:new-fist}

<<newace, echo=FALSE, cache=TRUE>>=

N25 <- read.ace("/home/ele/Data/454/assemblies/newbler/P_2011_07_12_23_05_13_runAssembly/454Isotigs.ace")
## The newbler Singletons without the addition of reads
## in contigs not present in the fasta
wrongNew <- merge(N25, RAW, by.x="read", by.y="ids", all=TRUE)
wrongNewblerSing <- unique(wrongNew[is.na(wrongNew$contig),]$read)

CNewbler <- read.sequences("/home/ele/Data/454/assemblies/newbler/P_2011_07_12_23_05_13_runAssembly/454Isotigs.fna")
Newblercontig.names <- substr(names(CNewbler), 1, 11)
N25 <- N25[N25$contig%in%Newblercontig.names,]

## Merge the data-frame to get our goal data-strukture
MIR.merged <- merge(MIR, RAW, by.x="read", by.y="ids", all=TRUE)
MERGED <- merge(N25, MIR.merged, by="read", all=TRUE)

MiraSing <- unique(MERGED[is.na(MERGED$contig.y),]$read)
NewblerSing <- unique(MERGED[is.na(MERGED$contig.x),]$read)

@ 

<<writeSing, echo=FALSE>>=
write.sequence(trimmed.fasta[names(trimmed.fasta)
                             %in%NewblerSing],
               "/home/ele/Data/454/assemblies/blasts/Newbler_Single.fasta")

write.sequence(trimmed.fasta[names(trimmed.fasta)
                             %in%MiraSing],
               "/home/ele/Data/454/assemblies/blasts/Mira_Single.fasta")

@ 

<<readsec, echo=FALSE, >>=
contigs <- read.sequences("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.contigs")
contigs <- c(contigs, read.sequences("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.singlets"))
names(contigs) <- sub(" .*$", "", names(contigs))

@ 

During transcriptome-assembly (with options -cdna -urt) Newbler can
split individual reads spanning the breakpoints of alternate isoforms,
to assemble e.g. the first portion of the reads in one contig, the
second portion in two different contigs. Later multiple so called
isotigs would be constructed and reported, one for each putative
transcript-variant. While this approach could be helpful for the
detection of alternate isoforms, it also produces short contigs
(especially at error-prone edges of high-coverage transcripts) when
the building of isotigs fails. The read-status report and the assembly
output in ace-format the program provides are including short contigs
only used during the assembly-process, but not reported in the
contigs-file used in transcriptome-assembly projects
(454Isotigs.fna). Therefore to get all reads not included in contigs
(i.e. a consistent definition of ``singleton'') it was necessary to
add all reads appearing only in contigs not reported in the fasta-file
to the reported singletons. The number of singletons increased in this
step form the \Sexpr{length(wrongNewblerSing)} reported to
\Sexpr{length(NewblerSing)}. We later also address the usefulness of
Newbler's report vs. the expanded singleton-category, but for the
meantime we define singletons as all reads not present in a given
assembly.

\newpage
  
<<newdist,  echo=FALSE, cache=TRUE>>=
## Plot the distribution of read-splitting occuring in Newbler ###
## Numbers of reads per Newbler-contig
## are visble by the amount a read-name is repeated

n25d <- as.data.frame(table(N25$read))
## One means no split!!
names(n25d)[2] <- "new.split"
n25d$new.split[n25d$new.split==1] <- 0

MERGED <- merge(MERGED, n25d, by.x="read",
                by.y="Var1", all=TRUE)

n25.dist <- ggplot(MERGED, aes(x=new.split, y=..count..)) +
  geom_bar(binwidth=2, color="white") +
  scale_y_continuous("number of reads") +
  scale_x_continuous("number of contigs/isotigs a read is appearing in") +
  theme_bw()

@ 

\begin{figure}[H]
  \centering
  
<<echo=FALSE, fig=TRUE>>=
print(n25.dist, width=12)
@ 

\caption{A histogram of the number of contigs/isotigs Newbler splitted
  one read into.}
  \label{fig:newdist}
\end{figure}

As mentioned above, the splitting of reads in the Newbler assembly can
give useful information on possible isoforms, however, the number of
contigs \texttt{Newbler} split one read into (in some cases more than
100 contigs) seems artificially inflated (see figure
\ref{fig:newdist}). If information would correspond to real isoforms
it should be about an order of magnitude lower. This fact emphasises
the need for further processing of the contigs. The maximum number of
read-splits in a given contig and its usefulness will be discussed
later in greater detail.

\section{The Mira-assembly and the second-order assembly}
\label{sec:assembly-sec}

The Mira assembly (with options --job=denovo,est,accurate,454)
provided a second estimate of the transcriptome. In this assembly
individual reads are not split. The number of reads not used in the
Mira-assembly was \Sexpr{length(MiraSing)}.

To combine the two assemblies Cap3 was used with default parameters
and including the quality information from first-order assemblies. The
reminder of this text deals with the exploratory analysis of how
information from both estimates of the transcriptome are integrated
into the final second-order assembly.

<<pc, echo=FALSE, results=tex>>=
pc <- read.delim("/home/ele/Data/454/assemblies/pc/contig_stats.txt")[, -c(24:30)]
pc$Filename <- gsub("\\/.*", "", pc$Filename)
names(pc)[1:9] <- c("assembly", "Max length", "Number of contigs", "Number of Bases", "N50", "Number of congtigs in N50", "mean GC", "non ATGC bases", "Mean length") 
pc[,9] <- round(pc[,9] )


P <- as.data.frame(t(pc[,c(2:6, 8, 9)]))
names(P) <- c("Newbler", "Mira", "Second-order(MN)") 
xtable(P, display=c("d","d","d","d"), label="tab:pc",
caption= "Basic statistics for the first-order assemblies and the second-order assemly (for which only the most relieable category of contigs is shown \ref{sec:data-categ-second})")
@ 

Table \ref{tab:pc} gives basic summary-statistics of the different
assemblies. Mira clearly produced the biggest assembly, both in terms
of number of contigs and bases), the second-order assembly is slightly
smaller size than the Newbler assembly.  The second-order assembly had
on average longer contigs than both first-order assemblies and a
higher weighted median contig size (N50).

<<singmerge, echo=FALSE, cache=TRUE>>=
## this categorizing has to come before the blast...
frass <- unique(MERGED[is.na(MERGED$contig.x) & is.na(MERGED$contig.y),]$read)
frass.fasta <- trimmed.fasta[names(trimmed.fasta)%in%frass]
super.frass <- frass[frass%in%wrongNewblerSing]
super.frass.fasta <- trimmed.fasta[names(trimmed.fasta)%in%super.frass]
        
SnO <- read.ace("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.ace")
MERGED <- merge(MERGED, SnO, by.x="contig.x", by.y="read", all.x=TRUE)
names(MERGED)[ncol(MERGED)] <- "SndO.NewblerContig"

MERGED <- merge(MERGED, SnO, by.x="contig.y", by.y="read", all.x=TRUE)
names(MERGED)[ncol(MERGED)] <- "SndO.MiraContig"
@ 

<<categorize, echo=FALSE, cache=TRUE>>=

MN <- c(as.character(MERGED[MERGED$SndO.MiraContig%in%MERGED$SndO.NewblerContig,]$SndO.MiraContig),
        as.character(MERGED[MERGED$SndO.NewblerContig%in%MERGED$SndO.MiraContig,]$SndO.NewblerContig))
MN <- unique(MN[!is.na(MN)])

M_n <- MERGED[!MERGED$SndO.MiraContig%in%MERGED$SndO.NewblerContig,]$SndO.MiraContig
M_n <- unique(M_n[!is.na(M_n)])

N_n <- MERGED[!MERGED$SndO.NewblerContig%in%MERGED$SndO.MiraContig,]$SndO.NewblerContig
N_n <- unique(N_n[!is.na(N_n)])

N_1<- by(MERGED, MERGED$contig.x,
         function (x) all(is.na(x$SndO.NewblerContig)))
N_1 <- names(N_1[N_1 & !is.na(N_1)])

M_1<- by(MERGED, MERGED$contig.y,
         function (x) all(is.na(x$SndO.MiraContig)))
M_1 <- names(M_1[M_1 & !is.na(M_1)])

M_n.contigs <- unique(MERGED[MERGED$SndO.MiraContig%in%M_n,]$contig.y)

N_n.contigs <- unique(MERGED[MERGED$SndO.NewblerContig%in%N_n,]$contig.x)

        
MN.newbler <- unique(MERGED[MERGED$SndO.NewblerContig%in%MN, ]$contig.x)

MN.mira <- unique(MERGED[MERGED$SndO.MiraContig%in%MN, ]$contig.y)

## need unique here to get no newbler duplicates
MN.reads.mira <- unique(MERGED[MERGED$SndO.MiraContig%in%MN ,]$read)

## no unique here to get also the dplicates
MN.reads.newbler <- MERGED[MERGED$SndO.NewblerContig%in%MN ,]$read

## also here remove reads duplicated by newbler for  mira reads
MN.reads.inc <- MERGED[(MERGED$read%in%MN.reads.mira & !duplicated(MERGED$read)) |
                   (MERGED$read%in%MN.reads.newbler & !duplicated(MERGED$read)) ,]$read

MN.reads.both <- MERGED[MERGED$read%in%MN.reads.mira  & !duplicated(MERGED$read) &
                   MERGED$read%in%MN.reads.newbler ,]$read

N_n.reads <- unique(MERGED[MERGED$SndO.NewblerContig%in%N_n,]$read)

M_n.reads <- unique(MERGED[MERGED$SndO.MiraContig%in%M_n,]$read)

M_1.reads <- unique(MERGED[MERGED$contig.y%in%M_1,]$read)

N_1.reads <- unique(MERGED[MERGED$contig.x%in%N_1,]$read)
@ 

\newpage
\section{Data-categories in the second-order assembly}
\label{sec:data-categ-second}

Three main categories of assembled sequence data can be distinguished
in the second-order assembly, each one with different reliability and
purpose in downstream applications:

The first category of data obtained are the singletons of the final
second-order assembly. It comprises raw sequencing reads that neither
of the first-order assemblers used. It is therefore the intersecion of
the Newbler-singletons (as defined in \ref{sec:new-fist}) and the
Mira-singletons. \Sexpr{length(frass)} reads fell in this category. A
second category of sequence contains the first-order contigs, that
could not be assembled in the second-order assembly (the singletons in
the Cap3-assembly; M\_1 and N\_1 in table
\ref{tab:categ}). Furthermore second-order contigs in which
first-order contigs from only one assembler are combined (M\_n and
N\_n in table \ref{tab:categ}) also have to be included in this
category. Sequences in this category should be considered only
moderately reliable as they are supported by only one assembly
algorithm.

Finally the category of contigs considered most reliable contains all
second-order contigs with contribution from both first-order
assemblies (MN in table \ref{tab:categ}).

<<tabulate, echo=FALSE, results=tex>>=
SndO.con <- cbind("M_1"=" ",
                   "M_n"=length(M_n),
                   "MN"=length(MN),
                   "N_n"=length(N_n),
                   "N_1"=" ")

FstO.con <- cbind(length(M_1),
                  length(M_n.contigs),
                  paste("mira=", length(MN.mira), "/",
                        "Newbler=", length(MN.newbler), sep=""),
                  length(N_n.contigs),
                  length(N_1))

reads <- cbind(length(M_1.reads),
                 length(M_n.reads),
                 length(MN.reads.inc),
                 unique(length(MN.reads.both)),
                 length(N_n.reads),
                 length(N_1.reads))

reads <- c(reads[c(1,2)],
           paste("one=", reads[3], "/", "both=", reads[4], sep=""),
           reads[c(5,6)])


MNtable <- rbind(SndO.con, FstO.con, reads)
 
row.names(MNtable) <- c("Snd.o.con", "Fst.o.con", "reads")

xtable(MNtable, caption="\\small{\\textbf{Number of reads, first-order contigs (Fst.o.con) and second-order contigs (Snd.o.con) for different categories of contigs (M\\_1 and N\\_1 = first-order contigs not assembled in second-order assembly, from mira and newbler respectively; M\\_n and N\\_n =  assembled in second-order contigs only with contigs from the same first-order assembly; MN = assembled in second-order contigs with first order contigs from both first order assemblies}}", label="tab:categ")

@ 

For this last, most reliable (MN) category, reads contained in the
assembly can be categorised depending on whether they entered the
assembly via both or only via one first-order assembly.

\newpage

\begin{figure}[H]
  \centering
  
<<convenn, echo=FALSE>>=

vennData <- cbind(through_mira=MERGED$read%in%MN.reads.mira,
                  as_duplicates=duplicated(MERGED$read)&
                  (!MERGED$read%in%MN.reads.mira|MERGED$read%in%MN.reads.newbler),
                  through_newbler=MERGED$read%in%MN.reads.newbler)
@ 

<<echo=FALSE, fig=TRUE>>=
vennDiagram(vennData, cex=0.9)
@ 

  \caption{The way of reads into the most reliable (MN) assembly-category}
  \label{fig:venncat}
\end{figure}

Figure \ref{fig:venncat} gives a more detailed view of the fate of the
reads Newbler splited during first-order assembly. Interestingly most
reads Newbler splited ended in the high-quality category of the second
order assembly.

\section{Contribution of first-order assemblies to second-order contigs}
\label{sec:contr-firs-order}

<<contigdist, echo=FALSE, cache=TRUE>>=
mira.contigs.per.SndO <- by(MERGED, MERGED[,"SndO.MiraContig"], function (x) length(unique(x[!is.na(x$contig.y), ]$contig.y)))
mira.contigs.per.SndO[is.na(mira.contigs.per.SndO)] <- 0
mira.contigs.per.SndO <- as.data.frame(unlist(list(mira.contigs.per.SndO)))

newbler.contigs.per.SndO <- by(MERGED, MERGED[,"SndO.NewblerContig"], function (x) length(unique(x[!is.na(x$contig.x),]$contig.x)))
newbler.contigs.per.SndO[is.na(newbler.contigs.per.SndO)] <- 0
newbler.contigs.per.SndO <- as.data.frame(unlist(list(newbler.contigs.per.SndO)))

contigs.per.SndO <- merge(newbler.contigs.per.SndO, mira.contigs.per.SndO,by="row.names")
names(contigs.per.SndO) <- c("contig", "Newbler_contigs", "Mira_contigs")

@
  
<<readdist, echo=FALSE, cache=TRUE>>=
mira.reads.per.SndO <- by(MERGED, MERGED[,"SndO.MiraContig"], function (x) length(unique(x[!is.na(x$contig.y), ]$read)))
mira.reads.per.SndO[is.na(mira.reads.per.SndO)] <- 0
mira.reads.per.SndO <- as.data.frame(unlist(list(mira.reads.per.SndO)))

newbler.reads.per.SndO <- by(MERGED, MERGED[,"SndO.NewblerContig"], function (x) length(unique(x[!is.na(x$contig.x),]$read)))
newbler.reads.per.SndO[is.na(newbler.reads.per.SndO)] <- 0
newbler.reads.per.SndO <- as.data.frame(unlist(list(newbler.reads.per.SndO)))

reads.per.SndO <- merge(newbler.reads.per.SndO, mira.reads.per.SndO, by="row.names")
names(reads.per.SndO) <- c("contig", "reads_through_Newbler", "reads_through_Mira")

contig.df <- merge(as.data.frame(contigs), reads.per.SndO, by.x="row.names", by.y="contig", all=TRUE)
names(contig.df)[1:2] <- c("contig", "seq")
contig.df <- merge(contig.df, contigs.per.SndO, all=TRUE)

categories <- list(MN=MN, M_n=M_n, N_n=N_n, N_1=N_1, M_1=M_1)
categories <- melt(categories)
names(categories) <- c("contig", "category")
contig.df <- merge(contig.df, categories, all.x=TRUE)
        
contig.df$Newbler_contigs[is.na(contig.df$Newbler_contigs)] <-
ifelse(grepl("tig", contig.df$contig[is.na(contig.df$Newbler_contigs)]),
1, 0)

contig.df$Mira_contigs[is.na(contig.df$Mira_contigs)] <-
ifelse(grepl("Acrassus", contig.df$contig[is.na(contig.df$Mira_contigs)]),
1, 0)

contig.df$reads_through_Newbler[contig.df$Newbler_contigs==0] <- 0
contig.df$reads_through_Mira[contig.df$Mira_contigs==0] <- 0

contig.df$reads_through_Mira[is.na(contig.df$reads_through_Mira)] <-
sapply(contig.df[is.na(contig.df$reads_through_Mira),"contig"],
       function(x) {nrow(MIR[MIR$contig==x,])})

contig.df$reads_through_Newbler[is.na(contig.df$reads_through_Newbler)] <-
sapply(contig.df[is.na(contig.df$reads_through_Newbler),"contig"],
       function(x) {nrow(N25[N25$contig==x,])})

@

Looking at the contribution of contigs from each of the assemblies to
one second-order contig in figure \ref{fig:rcp}a it becomes clear,
that the Mira-assembly had a high number of redundant contigs. These
were assembled into the same contig by Newbler and finally also in one
second-order contig by Cap3.

<<readconplot, echo=FALSE>>=

c.p.SndO.plot <- ggplot(contig.df,
                        aes(x=Newbler_contigs, y=Mira_contigs)) +
        geom_jitter(size=1) + 
        scale_x_log10("number of newbler contigs") +
        scale_y_log10("number of mira contigs") +
        theme_bw()

r.p.SndO.plot <- ggplot(contig.df,
                        aes(x=reads_through_Newbler, y=reads_through_Mira)) +
       geom_point(size=1) +
       scale_x_log10("reads through newber") +
       scale_y_log10("reads through mira") +
       theme_bw()
@ 

\begin{figure}[H]
  \centering

<<echo=FALSE, fig=TRUE>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 1)))
vplayout <- function(x, y)
    viewport(layout.pos.row = x, layout.pos.col = y)

# Make each plot, in the correct location
print(c.p.SndO.plot, vp = vplayout(1, 1 ))
print(r.p.SndO.plot, vp = vplayout(2, 1 ))

grid.text("a",x=unit(0.01,"npc"),y=unit(0.9,"npc")) 
grid.text("b",x=unit(0.01,"npc"),y=unit(0.1,"npc")) 

@ 


\caption{Number of first-order contigs from both first-order
  assemblies for each second order contig (a) number of reads through
  Newbler and Mira for each second-order contig (b)}
\label{fig:rcp}
  
\end{figure}


A different picture emerges from the contribution of reads through
each of the first-order assemblies (figure \ref{fig:rcp}b).  Here, for
most second-order contigs many more reads are contributed through
Newbler-contigs. This is because Newbler has more reads summed over
all contigs caused by the duplication due to the splitting of reads.

\newpage

\section{Evaluation of the assemblies}
\label{sec:eval-three-assembl}

<<sujeval, echo=FALSE, cache=TRUE>>=

covred.common.blast <- function(blastpath, dbpath){

blast <- read.delim(blastpath, header=FALSE)
blast <- blast[!duplicated(blast$V1),]

BL <- list()
BL[["MN"]] <- blast[blast$V1%in%MN,]
BL[["MN+N_x"]] <- rbind(BL[["MN"]],
                        blast[blast$V1%in%c(N_1,N_n),])
BL[["MN+M_x"]] <- rbind(BL[["MN"]],
                      blast[blast$V1%in%c(M_1, M_n),])
BL[["MN+S"]] <- rbind(BL[["MN"]],
                      blast[blast$V1%in%frass,])
BL[["MN+N_x+S"]] <- rbind(BL[["MN+S"]],
                          blast[blast$V1%in%c(N_1, N_n),])
BL[["MN+M_x+S"]] <- rbind(BL[["MN+S"]],
                          blast[blast$V1%in%c(M_1, M_n),])
BL[["MN+M_x+N_x+S"]] <- blast[blast$V1%in%names(contigs)|
                        blast$V1%in%frass,]
BL[["FU"]] <- blast[blast$V1%in%names(contigs)|
                        blast$V1%in%super.frass,]
BL[["N"]] <- blast[blast$V1%in%Newblercontig.names,]
BL[["N+S"]] <- rbind(BL[["N"]], 
                     blast[blast$V1%in%NewblerSing,])
BL[["N+rS"]] <- rbind(BL[["N"]],
                      blast[blast$V1%in%wrongNewblerSing,])
BL[["M"]] <- blast[blast$V1%in%Miracontig.names,]
BL[["M+S"]] <- rbind(BL[["M"]],
                     blast[blast$V1%in%MiraSing,])

CR <- list()
for (w in names(BL)){
  write.table(BL[[w]],
  "/home/ele/Data/454/assemblies/blasts/tmp",
  col.names=FALSE, row.names=FALSE, quote=FALSE, sep="\t")
  command <- paste("/home/ele/genepool/user/sujai/blast_mask.pl -d",
 dbpath,
 "-redundancy /home/ele/Data/454/assemblies/blasts/tmp 2>&1 1>/dev/null")
   CR[[w]] <- read.delim(pipe(command),
   header=FALSE)
  unlink("/home/ele/Data/454/assemblies/blasts/tmp")
  }
CR <- melt(CR, id.vars=c("V1", "V2", "V3","V4","V5"))
}

Bm.all <- covred.common.blast("/home/ele/Data/454/assemblies/blasts/ALL.fasta_vs_Bm.blt", "/drobo/db/blastdb/uniref100/uniref100_bm.fasta")
Bm.all <- cbind(Bm.all, db="B. malayi")

Ce.all <- covred.common.blast("/home/ele/Data/454/assemblies/blasts/ALL.fasta_vs_Ce.blt", "/drobo/db/blastdb/wormpep220/wormpep220.fasta")
Ce.all <- cbind(Ce.all, db="C. elegans")

ALL <- rbind(Ce.all, Bm.all)
names(ALL)[3:5] <- c("covered", "uncovered", "CovRed")
A <- ALL[,c(3:7)]

suj.summary <- function (x){
  w <- sum(x[,1])/sum(c(x[,1], x[,2]))*100
  y <- nrow(x[x[,1]>0,])/nrow(x)*100
  y80 <- nrow(x[x[,1]>(x[,1]+x[,2])*0.8,])/nrow(x)*100
  z <- sum(x[x[,1]>0,3])
  c("base_cov"=w, "prot_cov" =y, "prot_cov80p" =y80,  sum.CovRed=z)
}
suj.sum <- do.call("rbind", by(A, as.factor(A$db):as.factor(A$L1), suj.summary))
suj.sum <- as.data.frame(suj.sum)
suj.sum$species <- gsub(":.*", "", row.names(suj.sum))
suj.sum$assembly <- gsub(".*:", "", row.names(suj.sum))

frass.nB <- sum(nchar(frass.fasta))
super.frass.nb <- (sum(nchar(super.frass.fasta)))
        
bases <- vector()
bases["MN"] <- sum(nchar(contigs[names(contigs)%in%MN]))
bases["MN+S"] <- bases["MN"]+frass.nB
bases["MN+M_x"] <- bases["MN"] + sum(nchar(contigs[names(contigs)%in%c(N_n, N_1)]))
bases["MN+N_x"] <- bases["MN"] + sum(nchar(contigs[names(contigs)%in%c(M_n, M_1)]))
bases["MN+M_x+S"] <- bases["MN+S"] + sum(nchar(contigs[names(contigs)%in%c(N_n, N_1)]))
bases["MN+N_x+S"] <- bases["MN+S"] + sum(nchar(contigs[names(contigs)%in%c(M_n, M_1)]))
bases["MN+M_x+N_x+S"] <- sum(frass.nB, sum(nchar(contigs)))
bases["FU"] <- sum(super.frass.nb, sum(nchar(contigs)))
bases["N"] <- sum(nchar(CNewbler))
bases["N+S"] <- bases["N"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%NewblerSing]))
bases["N+rS"] <- bases["N"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%wrongNewblerSing]))
bases["M"] <- sum(nchar(CMira))
bases["M+S"] <- bases["M"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%NewblerSing]))

suj.sum <- merge(suj.sum, as.data.frame(bases), by.x="assembly", by.y="row.names")

text.base <- ggplot(suj.sum, aes(x=bases, y=base_cov, label=assembly)) +
             geom_text(hjust=0, vjust=0, angle = 315, size=2) +
             geom_point() +
             facet_grid(species ~ ., scales="free_y") +
             scale_y_continuous("percent database-bases covered") +
             scale_x_continuous("bases in assembly") +
             theme_bw() +
             opts(strip.text.y = theme_text(face="italic", angle=90))

text.prot <- ggplot(suj.sum, aes(x=bases, y=prot_cov, label=assembly)) +
             geom_text(hjust=0, vjust=0, angle = 315, size=2) +
             geom_point() +
             facet_grid(species ~ ., scales="free_y") +
             scale_y_continuous("percent database-proteins hit") +
             scale_x_continuous("bases in assembly")+
             theme_bw() +
             opts(strip.text.y = theme_text(face="italic", angle=90))

text.prot80 <- ggplot(suj.sum, aes(x=bases, y=prot_cov80p, label=assembly)) +
               geom_text(hjust=0, vjust=1.1, angle = 328, size=2) +
               geom_point() +
               facet_grid(species ~., scales="free_y") +
               scale_y_continuous("percent database-proteins covered > 80% length") +
               scale_x_continuous("bases in assembly") +
               theme_bw() +
               opts(strip.text.y = theme_text(face="italic", angle=90))

bm.covred <- read.delim("/home/ele/Data/454/assemblies/blasts/Bm_vs_Ce_blastmask_sujai.out", header=FALSE, sep="\t")[,c(3:5)]
names(bm.covred) <- c("covered", "uncovered", "CovRed")

bm.ce.sum <- suj.summary(bm.covred)
@


To further compare assemblies (Mira or Newbler first-order assemblies
including or excluding their singletons) and the second-order assembly
(including different contigs-categories and singletons) we evaluated
the number of bases or proteins their contigs and singletons
(partially) cover in the related model-nematodes,
\textit{Caenorhabditis elegans} and \textit{Brugia malayi}. To this
purpose we used Blast (blastx e-value cut-off 1e-5) and a custom
perl-script provided by S. Kumar.

In addition, the size of the assembly can give an indication of
redundancy or artificially assembled data. If it increases without
improving the reference-coverage the dataset is likely to contain more
redundant or artificial information, a more parsimonious assembly
should be preferred.

The database-coverage for the two reference species can then be
plotted against the size of the assembly-dataset to estimate the
completeness conditional to the size of the assembly (figures
\ref{fig:basecov}, \ref{fig:protcov}, \ref{fig:prot80cov}).

From the assemblies excluding singletons (in the lower left corner
with lower size and database-coverage) the highly reliable
contig-category of the second-order assembly produced the highest
per-base coverage in both reference-species, with the Newbler assembly
on a second place and Mira producing the lowest
reference-coverage. When adding the contigs considered lower quality
supported by only one assembler to the second-order assembly the
reference-coverage increased moderately.

Including singletons the Mira and Newber assemblies were of increased
size. A comparison of the Newbler's reported singletons with all
singletons addet to the Newbler-assembly shows, that the reported
singletons increased reference-coverage to the same amount than all
singletons, while the non-reported singletons only increased the size
of the assembly. It can be concluded, that the latter contain hardly
any additional information but only error-prone or variant reads.

The second-order assembly including the intersection of first-order
singletons performed similar to the Newbler assembly for the number of
bases coverd, but was larger in size. Adding the less reliable set of
one-assembler supported second-order-contigs the assembly coverd the
most bases in both references. When not the singleton of the
second-order assembly (as defined in \ref{sec:new-fist}) but the
intersection of Newbler's ``reported singletons'' and Mira's
singletons were considered a very parsimonious assembly with high
reference-coverage (termed fullest assembly; and labeled FU in the
plots above) was obtained.

\begin{figure}[H]

<<echo=FALSE, fig=true>>=

print(text.base)

@ 
\caption{Base-content and reference-transcriptome coverage (in bases)
  for different assemblies and assembly-combinations (M = Mira; N =
  Newbler; $M+S$ = Mira + singletons; $N+S$ = Newbler plus singletons;
  $N+Sr$ = Newbler plus singletons reported in readstatus.txt; MN =
  second-order contigs supported by both first-order; $MN+N\_x$ =
  second-order MN plus contigs only supported by Newbler ($N\_x$ =
  $N\_n$ and $N\_1$); $MN+M\_x$ = same for Mira-first-order-contigs;
  $MN+M\_x+S$ and $MN+N\_x+S$ same with singletons; FU = second-order
  contigs supported by both or one assembler plus the intersection of
  Newbler reported singletons and Mira-singletons = the basis for the
  ``fullest assembly'' used in later analyses)}
\label{fig:basecov}
\end{figure}


\begin{figure}[H]

<<echo=FALSE, fig=true>>=

print(text.prot)

@ 
\caption{Base-content and reference-transcriptome coverage in percent
  of proteins hit for different assemblies and assembly-combinations
  (for category-abrevations see Figure \ref{fig:basecov}).}
\label{fig:protcov}
\end{figure}

Considering the reference-database with any kind of coverage the
second-order assembly performed less preferable. Excluding singletons
it was covering similar numbers of database-proteins than the
Newber-assembly and and was outperformed by the Mira-assembly,
although the latter showed again to be least parsimonious. The same
general picture emerged from this analysis when singletons were
considered additionally. Newbler and second-order assemblies coverd
similar amounts of reference-data.

\begin{figure}[H]

<<echo=FALSE, fig=true>>=

print(text.prot80)
## xtable(suj.sum, digits=2, label="tab:suj.sum", caption="bla")
@ 
\caption{Base-content and reference-transcriptome coverage in percent
  of proteins coverd to at least 80\% of their length for different
  assemblies and assembly-combinations (for category-abrevations see
  Figure \ref{fig:basecov})}
\label{fig:prot80cov}
\end{figure}

When database-proteins covered for at least to 80\% of their length
are considered the second-order assembly showed it's superiority: Both
ex- and including singletons the second-order assembly outperformed
the first-order assemblies. Moderate gains in reference coverage were
made again for the addition of dubious single-assembler supported
second-order contigs. We give most weight in our analysis to these
results as in average longer correct contigs will allow finding the
highest number of putative full-lenth genes.

Given this evaluation we defined a ``minimal adequate'' assembly as the
subset of contigs of the second-order assembly supported by both
assemblers (labeled MN above). Given the performance of the singletons
\texttt{Newbler} reported. We defined a ``fullest-assembly'' as all
second-order contigs (including those supported by only one assembler)
plus the intersection of reported \texttt{Newbler}-singletons and
\texttt{Mira} singletons.

The proportion of proteins covered in \textit{C. elegans} by
\textit{B. malayi} coding sequences was with
\Sexpr{round(bm.ce.sum["prot_cov"],2)}\% simimlar to our estimate for
the fullest (FU) assembly. The proporiton of bases
(\Sexpr{round(bm.ce.sum["base_cov"],2)}\%) and of proteins coverd to at
least 80\% of their length (\Sexpr{round(bm.ce.sum["prot_cov80p"],2)}\%)
was however higher for the coding sequences from \textit{B. malayi}.

\section{Measurments on second-order assembly}

Based on the tracking of reads through the complicated assembly
process, we calculated the following statistics for each contig in the
second-order assembly.

\begin{itemize}
\item number of Mira and Newbler first-order contigs
\item number of reads through Mira and reads through Newbler
\item number of reads being split by Newbler in first-order assembly
\item number of read-split events in the first-order assembly (equals
  the sum of reads multiplied by number of contigs a read has been
  split into)
\item maximal number of first-order contigs a read in the contig has
  been split into during Newbler-assembly
\item the number of reads same-read-paires from the Newbler and Mira
  first order-assembly merged in a second order contig
\item cluster-id of the contig: All contigs ``connected'' by sharing
  reads (similar to the graph clustering reported in
  \cite{pmid21138572}). 
\item number of other second order contigs containing the same read
  (size of the cluster)
\end{itemize}

<<echo=FALSE, cache=TRUE>>=
##  number of reads being split in first order assembly
num.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) nrow(x[x$new.split>1, ]))))
## The NA's, where there is no newbler contig in the SnO.contig can be replace by 1
num.new.split[is.na(num.new.split)] <- 0
contig.df <- merge(contig.df, num.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "num.new.split"

sum.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) sum(x$new.split))))
## The NA's, where there is no newbler contig in the SnO.contig can be replace by 1
sum.new.split[is.na(sum.new.split)] <- 0
contig.df <- merge(contig.df, sum.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "sum.new.split"

## per SndOcontig maximal number of N25 contigs read is split into
max.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) max(x$new.split))))
## The NA's, where there is no newbler
## contig in the SnO.contig can be replace by 0
max.new.split[is.na(max.new.split)] <- 0
contig.df <- merge(contig.df, max.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "max.new.split"

## the number of reads merged back into one second order contig
## num.SndO.merge <- do.call("rbind",
##                           as.list(by(MERGED, MERGED$SndO.NewblerContig,
##                                      function (x) {
##                                        nrow(x[x$SndO.MiraContig!=x$SndO.NewblerContig
##                                               & !is.na(x$SndO.MiraContig)
##                                               & !is.na(x$SndO.NewblerContig),])
##                                      })))
## num.SndO.merge[is.na(num.SndO.merge)] <- 0
## contig.df <- merge(contig.df, num.SndO.merge, by.x="contig", by.y="row.names", all.x=TRUE)
## names(contig.df)[ncol(contig.df)] <- "num.SndO.merge"

num.SndO.pair <- do.call("rbind",
                          as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                     function (x) {
                                       nrow(x[x$SndO.MiraContig==x$SndO.NewblerContig
                                              & !is.na(x$SndO.MiraContig)
                                              & !is.na(x$SndO.NewblerContig),])
                                     })))
num.SndO.pair[is.na(num.SndO.pair)] <- 0
contig.df <- merge(contig.df, num.SndO.pair, by.x="contig", by.y="row.names", all.x=TRUE)
names(contig.df)[ncol(contig.df)] <- "num.SndO.pair"
@ 

<<cluster, echo=FALSE, cache=TRUE>>=
SndO <- cbind(as.character(MERGED$SndO.NewblerContig), as.character(MERGED$SndO.MiraContig))
SndO <- SndO[SndO[,1]!=SndO[,2] & !is.na(SndO[,1]) & !is.na(SndO[,2]),]
a <- apply(SndO, 1 , list)

add.up.clusters <- function (clustlist){
  clustlist <- unique(clustlist)
  clus <- list()
  for(k in 1:length(clustlist)){
    e <- sapply(1:length(clustlist),function (i) {
      any(unlist(clustlist[k]) %in% unlist(clustlist[i]))
    })
    clus[[k]] <- unique(unlist(clustlist[e]))
  }
  return(unique(clus))
}

## make it work recursively to fully collapse clusters
recursive.cluster <- function(clusterlist){
  res <- list(NA, clusterlist)
  while(length(res[[length(res)]])!=length(res[[length(res)-1]])){
    res[[length(res)+1]] <- add.up.clusters(res[[length(res)]])
  }
  return(res[[length(res)]])
}

SndO.clusters <- recursive.cluster(a)


names(SndO.clusters) <- paste("CL", 1:length(SndO.clusters), sep="")

SndO.cluster.id <- melt(SndO.clusters)
names(SndO.cluster.id) <- c("contig", "cluster.id")
                                    
write(unlist(lapply(SndO.clusters, paste, collapse=" ")),
      file="/home/ele/thesis/454/SndO.clusters")
                                    
SndO.cluster.size <- as.data.frame(do.call("rbind",
                                           lapply(SndO.clusters,
                                                  function (x)
                                                  cbind(contig=x, cluster.size=length(x)))))
SndO.cluster.size$cluster.size <- as.numeric(as.character(SndO.cluster.size$cluster.size))

contig.df <- merge(contig.df, SndO.cluster.id,  all=TRUE)
contig.df <- merge(contig.df, SndO.cluster.size,  all=TRUE)

contig.df$cluster.size <- ifelse(is.na(contig.df$cluster.size), 1, contig.df$cluster.size)

super.frass.frame <- as.data.frame(super.frass.fasta)
super.frass.frame$contig <- row.names(super.frass.frame)
super.frass.frame <- super.frass.frame[,c(2,1)]
super.frass.frame[, 3:ncol(contig.df)] <- 0
names(super.frass.frame) <- names(contig.df)

contig.df <- rbind(contig.df, super.frass.frame)

#contig.df$num.SndO.merge[is.na(contig.df$num.SndO.merge)] <- 0
contig.df$num.SndO.pair[is.na(contig.df$num.SndO.pair)] <- 0
contig.df$num.new.split[is.na(contig.df$num.new.split)] <- 0
contig.df$sum.new.split[is.na(contig.df$sum.new.split)] <- 0
contig.df$max.new.split[is.na(contig.df$max.new.split)] <- 0
contig.df$cluster.id[is.na(contig.df$cluster.id)] <- 0
@ 

\subsection{Contig coverage}

\SweaveInput{../Method-assembly/pileup_read.Rnw}

As well defined coverage-information is not readyly avaiable from the
output of this combined assembly aproach (although we followed
individual reads through the process) we inferred coverage by mapping
the reads used for assembly against the fullest assembly using ssaha2
\cite{pmid11591649} with parameters (-kmer 13 -skip 3 -seeds 6 -score
100 -cmatch 10 -ckmer 6 -output sam -best 1):

\begin{itemize}
\item mean per base coverage
\item mean unique per base coverage
\end{itemize}

The ratio of mean per base coverage and unique per base coverage (the
standard for assessing coverage) can be used as to asses the
redundancy of a contig.

\subsection{Example use of the contig-measurements}

Based on these measurements the emergence of a given contig from the
assembly process can be reconstructed. Table \ref{tab:ex-me} gives an
excerpt of the contig-measurements reported in additional-file
contig-data.csv. The example contigs are all from large
contig-clusters (cluster.size), where interpretation of the assembly
history is complicated, but not impossible:

<<echo=FALSE, results=tex>>=

show <- head(contig.df[contig.df$cluster.size>12,c(1, 3:15) ], n=2)
show <- rbind(show,
              head(contig.df[contig.df$cluster.size>1 &
                             contig.df$category=="M_n" ,c(1, 3:15) ], n=1))
show <- rbind(show,
              head(contig.df[contig.df$cluster.size>1 &
                             contig.df$category=="N_n" ,c(1, 3:15) ], n=1))

row.names(show) <- show$contig
show$contig <- NULL
xtable(t(show), caption="example table for assembly-measurements on contigs (as given in
                         contig-data.csv)", label="tab:ex-me")
@ 

\textbf{Contig1047} is in the well trusted MN category of contigs. It
consists of only one contig from each first-order assembly
(newbler\_contigs and mira\_contigs), each containing a set of reads
of moderate size: 16 from Newbler (reads\_through\_newbler) 26 from
Mira (reads\_through\_mira). 8 of the 16 reads Newbler used in its one
assembled contig were also assembled to a differnt Newbler-contig
(num.new.split). That each of the 8 reads was only appearing in one
other Newbler-contig is visible from the fact, that the number of
split events is 16 (sum.new.split) and the maximal number of splits
for one read is 2 (max.new.split). 13 (num.SndO.pair) same-read-pairs
from the tow different first-order assemblies were merged in this
second-order contig, leaving 3 (16-13) reads in Newbler-contigs and 13
(26-13) reads in Mira contigs, which all could potentially have ended
up in other contigs. The contig is in a cluster (CL62), which contains
in total 24 contigs (cluster.size). It has to be addmitted that the
whole graph-structure linking this 24 contigs can't be reconstructed
from this contig summary data. On the other hand the summary data
makes clear, from what source the links for cluster-affiliation have
resulted: In this case from 3 and 13 unlinked read-paires from both
first-order assemblies and 8 split-reads from Newbler-first order
contigs.

A comprehensive interpretation of the other example-contigs depicted
is left to the reader. It should just be remarked, that in case of
one-assembler supported contigs, all reads in that contig could
potentially be represented in other contigs, making average
cluster-size in these contigs bigger than in MN category.\\

One of the most interesting measurement calculated for each contig is
the cluster-membership and cluster-size. Such clusters can represent
close paralogs, duplicated genes, isoforms from alternative splicing
or allelic variants.

These measurements can be used in later analysis to e.g. reevaluate
the likelihood of misassembly in a given set of biologically relevant
contigs. All gene-sets mentioned later (in chapter the main text) were
thus, as a matter of routine, controlled for unusual patterns in the
contig meta-data.

\section{Finalising the fullest assembly set}
\label{sec:final-full-assembly}

In order to minimize the amount of sequence with artificially inferred
isoform-breakpoints we used the unique-mapping-information described
above to detect contigs and singletons not supported by any raw data
(reads). Table \ref{tab:cov.ex} gives a summary of these unsupported
data by contig-category. For all downstream-analysis we removed the
all well trusted MN-category-contigs no coverage and the contigs (and
singletons) from other categories having no unique coverage.

<<echo=FALSE, results=tex>>=

cov.ex <- do.call("rbind",
                  list(by(contig.df, contig.df$category,
                          function (x) nrow(x[x$coverage==0, ]))))
cov.ex <- rbind(cov.ex, do.call("rbind",
                                list(by(contig.df, contig.df$category,
                                        function (x) nrow(x[x$uniq_coverage==0, ])))))

row.names(cov.ex) <- c("coverage == 0", "unique coverage == 0")
cov.ex <- data.frame(cov.ex)
names(cov.ex)[1] <- "singletons"

cov.ex.tab <- xtable(cov.ex,
                     caption= "number of contigs with a coverage and unique-coverage of zero, inferred from mapping of raw reads, listed by contig-category",
                     label="tab:cov.ex")
print(cov.ex.tab)

contig.df <- contig.df[contig.df$coverage>0, ]
contig.df <- contig.df[contig.df$uniq_coverage>0 | contig.df$category=="MN", ]

## Two last important measurements
contig.df$gc <- get.gc(contig.df$seq)
contig.df$length <- nchar(as.character(contig.df$seq))

@ 

Thereby we reduced our dataset to 40,187 tentative unique genes
(TUGs), redefining the ``fullest assembly'' dataset. Based on the
above evaluation we decided to treat the MN-category of contigs as
high credibility assembly (highCA) and to subsume the M\_n, N\_n,
M\_1, N\_1 and \texttt{Newbler's} reported singletons as additional
low credibility assembly (lowCA).

<<save, echo=FALSE>>=
## save what is needed downstream
save(file="Method.Rdata", list=c("contig.df", "con.pile", "con.pile.uniq", "per.con", "per.con.uniq", "raw.fasta", "nBases"))
fullest.assembly <- c(contigs ,
                      super.frass.fasta)[names(c(contigs, super.frass.fasta))%in%
                                         contig.df$contig] 

write.sequence(fullest.assembly, "/home/ele/thesis/454/fullest_assembly.fasta")
save.image(file="Method_image.Rdata")
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  The Bibliography                       %%
%%                                                         %%              
%%  Bmc_article.bst  will be used to                       %%
%%  create a .BBL file for submission, which includes      %%
%%  XML structured for BMC.                                %%
%%                                                         %%
%%                                                         %%
%%  Note that the displayed Bibliography will not          %% 
%%  necessarily be rendered by Latex exactly as specified  %%
%%  in the online Instructions for Authors.                %% 
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliographystyle{/home/ele/bibtex/bmc_article.bst} % Style BST file
\newpage
\bibliography{/home/ele/bibtex/master.bib} % Bibliography file (usually '*.bib' )




\end{document}
