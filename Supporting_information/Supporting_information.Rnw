%%% Supporting_information.Rnw --- 

%% Author: emanuelheitlinger@gmail.com

\documentclass[12pt,a4paper]{article}
\usepackage[debugshow,final]{graphics}
\usepackage{hyperref}
\usepackage{float}
\usepackage{lscape} 
\usepackage{rotating} 
 

\date{}
\begin{document}

\title{Addtional figures, tables and text describing the assembly
  process for ``The transcriptome of the invasive eel swimbladder
  nematode parasite \textit{Anguillicola crassus}'' (Heitlinger et
  al.)}

\maketitle
\tableofcontents
\listoffigures 
\listoftables

% make the plots modest size

\renewcommand{\figurename}{Additional Figure}
\renewcommand{\tablename}{Additional Table}

\section{Additional figures referenced in the main text}

\newpage
\clearpage

\begin{sidewaysfigure}
  \centering
\includegraphics{../figures/Additional_Figure_1.pdf}
\caption[Filtering of putative SNPs]{Filtering of putative SNPs. When
  SNPs in or adjacent to homopolymeric regions are removed changes in
  ti/tv and dn/ds are observed: as the overall number of SNPs is
  reduced both ratios change to more plausible values. Note the
  reversed axis for dn/ds to plot these lower values to the right. For
  homopolymer length $>$ 3 a linear trend for the total number of SNPs
  and the two measurements is observed. A width of 11 for the
  screening window provides most plausible values (suggesting
  specificity) while still incorporating a high number of SNPs
  (sensitivity).}
\end{sidewaysfigure}

\newpage
\clearpage

\begin{sidewaysfigure}
  \centering
\includegraphics{../figures/Additional_Figure_2.pdf}
\caption[SNP distribution is affected by codon position and
coverage]{SNP distribution is affected by codon position and
  coverage. Overabundance of SNPs at codon-position two (a) and of
  non-synonymous SNPs (c) for low percentages of the minority
  allele. (b) Significant positive correlation of coverage and dn/ds
  before removing these SNPs at a threshold of 7\% ($p<$ 0.001, $R^2=$
  0.015) and (d) absence of such a correlation afterwards ($p=$0.192,
  $R^2<$0.001).}
\end{sidewaysfigure}

\newpage
\clearpage

\begin{sidewaysfigure}
  \centering
\includegraphics{../figures/Additional_Figure_3.pdf}
\caption[Positive selection by categories of evolutionary
conservation]{Positive selection by categories of evolutionary
  conservation. Boxplot of dn/ds based on the screened set of SNPs in
  TUGs by different categories of evolutionary
  conservation. Significant comparisons are sequences novel in Metazoa
  vs. novel in \textit{A. crassus} (0.009 and 0.002; p-value for
  bitscore of 50 and 80, Nemenyi-Damico-Wolfe-Dunn test), in Nematoda
  vs. in \textit{A. crassus} (0.03 and 0.009). Sequences novel in
  Spirurina failed to show significantly elevated dn/ds, despite
  higher median values due to the low number of contigs of this
  category with a dn/ds obtained.}
\end{sidewaysfigure}

\newpage
\clearpage


\section{The transcriptome of \textit{A.crassus}}


\subsection{Sequencing, trimming and pre-assembly screening}

 A total of 756,363 raw sequencing reads were generated for
 \textit{A. crassus} (Table 1). These were trimmed for base call
 quality, and filtered by length to give 585,949 high-quality reads
 (spanning 169,863,104 bases). From \textit{An. japonica} liver RNA
 159,370 raw reads were generated, and 135,072 retained after basic
 quality screening. These eel reads were assembled into 10,639
 contigs. The \textit{A. crassus} reads were screened for
 contamination by host sequence by comparison to our assembled
 \textit{An. japonica} 454 transcriptome and publicly accessible
 \textit{An. anguilla} sequence data, and 30,071 reads removed. By
 comparison to \textit{A. crassus} small subunit ribosomal RNA
 (sequenced previously) and large subunit ribosomal RNA (assembled
 from our reads in preliminary analyses), 181,783 were tagged and
 removed. The L2 library proved to have contributions for other
 cobionts of the eel, and 5,286 reads were removed because they
 matched closely to cercozoan (likely parasite) ribosomal RNA genes.



<<load, echo=FALSE, results=hide>>=
library(lattice)
library(ggplot2)
library(MASS)
library(xtable)
library(reshape)

## library(Design)
library(limma)
library(VennDiagram)
source("/home/ele/thesis/454/common_R_functions.R")
@ 

<<functions_read, echo=FALSE, cache=TRUE>>=

mean.qual <- function(q){
  lapply(q, function(x) {w <- unlist(strsplit(x, " "))
                                    mean(as.numeric(w[nchar(w)>0]))})
}

raw.fasta <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_in.454.fasta")

raw.qual <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_in.454.fasta.qual")

qualmeans <- mean.qual(raw.qual)

ids <- substr(names(raw.fasta),1, 14)
seqlength <- nchar(raw.fasta)

RAW <- as.data.frame(cbind(ids=as.character(ids),
                           qualmeans=as.numeric(qualmeans),
                           seqlength=as.numeric(seqlength)))

nFLX <- length(grep("^F.*",perl=T,names(raw.fasta),value=T))
nTIT <- length(grep("^G.*",perl=T,names(raw.fasta), value=T))

## raw.fasta contains all trimmed bases in lower-case
trimmed.fasta <- gsub("[a-z]", "", raw.fasta)
nBases <- sum(nchar(trimmed.fasta))

trimmed.qual <- list()
for (l in (c("10F", "179F", "M175", "L2R3", "KS4F", "UW07F"))){
  command <- paste("/home/ele/tools/Newbler2.6/bin/sffinfo -q /home/ele/Data/454/pre_assembly_screening/final.", l, ".sff.trimmed.sff;", sep="")
  connect <- pipe(command)
  trimmed.qual[l] <- list(read.sequences(connect))
  closeAllConnections()
}

trimmed.qual <- unlist(trimmed.qual)
names(trimmed.qual) <- gsub(" .*$", "", names(trimmed.qual))
names(trimmed.qual) <- gsub("^.*\\.", "", names(trimmed.qual))

@ 

\section{ Evaluating a method of combining assemblies}

\subsection{Overview}
\label{sec:overview}

The pre-processed \textit{A. crassus} data-set consisting of
\Sexpr{nBases} bases in \Sexpr{length(raw.fasta)} reads (\Sexpr{nFLX}
generated using ``FLX-chemistry'', \Sexpr{nTIT} using
``Titanium-chemistry'') was assembled following an approach proposed
by \cite{pmid20950480}: two assemblies were generated, one using
Newbler v2.6 \cite{pmid16056220}, the other using Mira v3.2.1
\cite{miraEST}. The resulting assemblies (referred to as first-order
assemblies) were merged with Cap3 \cite{Cap3_Huang} into a combined
assembly (referred to as second-order assembly).

<<mirace, cache=TRUE, echo=FALSE>>=

read.ace <- function (path){
  command <- paste("perl -ne '$c =  $1 if /^CO (\\S+)/;",
                   "print \"$c $1\\n\"if /^AF (\\w+)(\\|*|\\.*)/'",
                   path)                    # last bit to get rid of
                                            # newblers .info and my
                                            # own |readcount
#  closeAllConnections()
  ace <- read.table(pipe(command), sep=" ")
  names(ace) <- c("contig", "read")
  return(ace)
}

MIR <- read.ace("/home/ele/Data/454/assemblies/mira/Acrassus_assembly/Acrassus_d_results/Acrassus_out.ace")
CMira <- read.sequences("/home/ele/Data/454/assemblies/mira/Acrassus_assembly/Acrassus_d_results/Acrassus_out.unpadded.fasta")
Miracontig.names <- names(CMira)
@

\subsection{The Newbler first-order assembly}
\label{sec:new-fist}

<<newace, echo=FALSE, cache=TRUE>>=

N25 <- read.ace("/home/ele/Data/454/assemblies/newbler/P_2011_07_12_23_05_13_runAssembly/454Isotigs.ace")
## The newbler Singletons without the addition of reads
## in contigs not present in the fasta
wrongNew <- merge(N25, RAW, by.x="read", by.y="ids", all=TRUE)
wrongNewblerSing <- unique(wrongNew[is.na(wrongNew$contig),]$read)

CNewbler <- read.sequences("/home/ele/Data/454/assemblies/newbler/P_2011_07_12_23_05_13_runAssembly/454Isotigs.fna")
Newblercontig.names <- substr(names(CNewbler), 1, 11)
N25 <- N25[N25$contig%in%Newblercontig.names,]

## Merge the data-frame to get our goal data-strukture
MIR.merged <- merge(MIR, RAW, by.x="read", by.y="ids", all=TRUE)
MERGED <- merge(N25, MIR.merged, by="read", all=TRUE)

MiraSing <- unique(MERGED[is.na(MERGED$contig.y),]$read)
NewblerSing <- unique(MERGED[is.na(MERGED$contig.x),]$read)

@ 

<<writeSing, echo=FALSE>>=
write.sequence(trimmed.fasta[names(trimmed.fasta)
                             %in%NewblerSing],
               "/home/ele/Data/454/assemblies/blasts/Newbler_Single.fasta")

write.sequence(trimmed.fasta[names(trimmed.fasta)
                             %in%MiraSing],
               "/home/ele/Data/454/assemblies/blasts/Mira_Single.fasta")

@ 

<<readsec, echo=FALSE, >>=
contigs <- read.sequences("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.contigs")
contigs <- c(contigs, read.sequences("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.singlets"))
names(contigs) <- sub(" .*$", "", names(contigs))

@ 

During transcriptome assembly (with options -cdna -urt) Newbler can
split individual reads spanning the breakpoints of alternate isoforms,
to assemble e.g. the first portion of the reads in one contig and the
second portion in two different contigs. Subsequently, multiple so
called isotigs are constructed and reported, one for each putative
transcript variant. While this approach could be helpful for the
detection of alternate isoforms, it also produces short contigs
(especially at error-prone edges of high-coverage transcripts) when
the building of isotigs fails. The read status report and the assembly
output in ace format the program provides include short contigs only
used during the assembly process, but not reported in the contigs file
used in transcriptome-assembly projects (454Isotigs.fna). Therefore to
get all reads not included in contigs (i.e. a consistent definition of
``singleton'') it was necessary to add all reads appearing only in
contigs not reported in the fasta file to the reported singletons. The
number of singletons increased in this step from the
\Sexpr{length(wrongNewblerSing)} reported to
\Sexpr{length(NewblerSing)}. We later also address the usefulness of
Newbler's report vs. the expanded singleton-category, but for the
meantime we define singletons as all reads not present in contigs
reported from a given assembly.

\newpage
  
<<newdist,  echo=FALSE, cache=TRUE>>=
## Plot the distribution of read-splitting occuring in Newbler ###
## Numbers of reads per Newbler-contig
## are visble by the amount a read-name is repeated

n25d <- as.data.frame(table(N25$read))
## One means no split!!
names(n25d)[2] <- "new.split"
n25d$new.split[n25d$new.split==1] <- 0

MERGED <- merge(MERGED, n25d, by.x="read",
                by.y="Var1", all=TRUE)

n25.dist <- ggplot(MERGED, aes(x=new.split, y=..count..)) +
  geom_bar(binwidth=2, color="white") +
  scale_y_continuous("number of reads") +
  scale_x_continuous("number of contigs/isotigs a read appears in") +
  theme_bw()

@ 

\begin{figure}[H]
  \centering
  
<<echo=FALSE, fig=TRUE>>=
print(n25.dist, width=12)
@ 

\caption{A histogram of the number of contigs/isotigs that individual
  reads are split into by the Newbler assembly.}
  \label{fig:newdist}
\end{figure}

While, the splitting of reads in the Newbler assembly can give useful
information on possible isoforms, the number of contigs Newbler split
one read into (in some cases more than 100 contigs) seems inflated
(see additional figure \ref{fig:newdist}). This emphasises the need
for further processing of the contigs. The maximum number of read
splits in a contig and its usefulness in estimating contig quality
will be discussed later in greater detail.

\subsection{The Mira assembly and the second-order assembly}
\label{sec:assembly-sec}

The Mira assembly (with options --job=denovo,est,accurate,454)
provided a second estimate of the transcriptome. In this assembly
individual reads were not split. The number of reads not used in the
Mira assembly was \Sexpr{length(MiraSing)}.

To combine the two assemblies Cap3 was used with default parameters
and the quality information from first-order assemblies was
included. Below, we explore how information from both estimates of the
transcriptome were integrated into the final second-order assembly.

<<pc, echo=FALSE, results=tex>>=
pc <- read.delim("/home/ele/Data/454/assemblies/pc/contig_stats.txt")[, -c(24:30)]
pc$Filename <- gsub("\\/.*", "", pc$Filename)
names(pc)[1:9] <- c("assembly", "Max length", "Number of contigs", "Number of Bases", "N50", "Number of congtigs in N50", "mean GC", "non ATGC bases", "Mean length") 

pc$"Number of singletons" <- c(paste(length(wrongNewblerSing), length(NewblerSing), sep="/"),
                               length(MiraSing),
                               paste(length(intersect(MiraSing, wrongNewblerSing)),
                                     length(intersect(MiraSing, NewblerSing)), sep="/"))

pc$"Span of singletons" <- c(paste(sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%wrongNewblerSing])),
                                   sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%NewblerSing])),
                                   sep="/"),
                             sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%MiraSing])),
                             paste(sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%
                                                            intersect(wrongNewblerSing, MiraSing)])),
                                   sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%
                                                            intersect(NewblerSing, MiraSing)])),
                                   sep="/"))

pc[,9] <- round(pc[,9] )

P <- as.data.frame(t(pc[,c(2:6, 8, 9, 24, 25)]))
names(P) <- c("Newbler", "Mira", "Second-order(MN)") 
xtable(P, display=c("d","d","d","d"), label="tab:pc",
caption= c("Basic statistics for the first-order assemblies and the second-order assembly (for which only the most reliable category of contigs is shown. For Newbler the number of singletons is given as defined above as ``unused reads'' and as reported. Singletons for the second-order assembly are the intersection of these with the Mira singletons.", "Basic statistics for the first-order assemblies and the second-order assembly"))
@ 

Additional table \ref{tab:pc} gives summary statistics of the different
assemblies. Mira clearly produced the biggest assembly, both in terms
of number of contigs and bases). The second-order assembly is slightly
smaller than the Newbler assembly.  The second-order assembly had on
average longer contigs than both first-order assemblies and a higher
weighted median contig size (N50).

<<singmerge, echo=FALSE, cache=TRUE>>=
## this categorizing has to come before the blast...
frass <- unique(MERGED[is.na(MERGED$contig.x) & is.na(MERGED$contig.y),]$read)
frass.fasta <- trimmed.fasta[names(trimmed.fasta)%in%frass]
super.frass <- frass[frass%in%wrongNewblerSing]
super.frass.fasta <- trimmed.fasta[names(trimmed.fasta)%in%super.frass]
        
SnO <- read.ace("/home/ele/Data/454/assemblies/second_order/Ac.fasta.cap.ace")
MERGED <- merge(MERGED, SnO, by.x="contig.x", by.y="read", all.x=TRUE)
names(MERGED)[ncol(MERGED)] <- "SndO.NewblerContig"

MERGED <- merge(MERGED, SnO, by.x="contig.y", by.y="read", all.x=TRUE)
names(MERGED)[ncol(MERGED)] <- "SndO.MiraContig"
@ 

<<categorize, echo=FALSE, cache=TRUE>>=

MN <- c(as.character(MERGED[MERGED$SndO.MiraContig%in%MERGED$SndO.NewblerContig,]$SndO.MiraContig),
        as.character(MERGED[MERGED$SndO.NewblerContig%in%MERGED$SndO.MiraContig,]$SndO.NewblerContig))
MN <- unique(MN[!is.na(MN)])

M_n <- MERGED[!MERGED$SndO.MiraContig%in%MERGED$SndO.NewblerContig,]$SndO.MiraContig
M_n <- unique(M_n[!is.na(M_n)])

N_n <- MERGED[!MERGED$SndO.NewblerContig%in%MERGED$SndO.MiraContig,]$SndO.NewblerContig
N_n <- unique(N_n[!is.na(N_n)])

N_1<- by(MERGED, MERGED$contig.x,
         function (x) all(is.na(x$SndO.NewblerContig)))
N_1 <- names(N_1[N_1 & !is.na(N_1)])

M_1<- by(MERGED, MERGED$contig.y,
         function (x) all(is.na(x$SndO.MiraContig)))
M_1 <- names(M_1[M_1 & !is.na(M_1)])

M_n.contigs <- unique(MERGED[MERGED$SndO.MiraContig%in%M_n,]$contig.y)

N_n.contigs <- unique(MERGED[MERGED$SndO.NewblerContig%in%N_n,]$contig.x)

        
MN.newbler <- unique(MERGED[MERGED$SndO.NewblerContig%in%MN, ]$contig.x)

MN.mira <- unique(MERGED[MERGED$SndO.MiraContig%in%MN, ]$contig.y)

## need unique here to get no newbler duplicates
MN.reads.mira <- unique(MERGED[MERGED$SndO.MiraContig%in%MN ,]$read)

## no unique here to get also the dplicates
MN.reads.newbler <- MERGED[MERGED$SndO.NewblerContig%in%MN ,]$read

## also here remove reads duplicated by newbler for  mira reads
MN.reads.inc <- MERGED[(MERGED$read%in%MN.reads.mira & !duplicated(MERGED$read)) |
                   (MERGED$read%in%MN.reads.newbler & !duplicated(MERGED$read)) ,]$read

MN.reads.both <- MERGED[MERGED$read%in%MN.reads.mira  & !duplicated(MERGED$read) &
                   MERGED$read%in%MN.reads.newbler ,]$read

N_n.reads <- unique(MERGED[MERGED$SndO.NewblerContig%in%N_n,]$read)

M_n.reads <- unique(MERGED[MERGED$SndO.MiraContig%in%M_n,]$read)

M_1.reads <- unique(MERGED[MERGED$contig.y%in%M_1,]$read)

N_1.reads <- unique(MERGED[MERGED$contig.x%in%N_1,]$read)
@ 

\newpage
\subsection{Data categories in the second-order assembly}
\label{sec:data-categ-second}

Three main categories of assembled sequence data can be distinguished
in the second-order assembly, each one with different reliability and
utility in downstream applications:

The first category of data obtained are the singletons of the final
second-order assembly. It comprises raw sequencing reads that neither
of the first-order assemblers used. It is therefore the intersecion of
the Newbler singletons (as defined in \ref{sec:new-fist}) and the Mira
singletons. \Sexpr{length(frass)} reads fell in this category. A
second category of sequence is the first-order contigs that were not
assembled in the second-order assembly (the singletons in the Cap3
assembly; M\_1 and N\_1 in additional table
\ref{tab:categ}). Second-order contigs in which first-order contigs
from only one assembler are combined (M\_n and N\_n in additional
table \ref{tab:categ}) were also included in this category. We
consider sequences in this category as only moderately reliable, as
they are supported by only one assembly algorithm. The category of
contigs considered the most reliable contains all second-order contigs
with contribution from both first-order assemblies (MN in additional
table \ref{tab:categ}). For this last, most reliable (MN) category,
reads contained in the assembly can be categorised depending on
whether they entered the assembly via both or only via one first-order
assembly.

<<tabulate, echo=FALSE, results=tex>>=
SndO.con <- cbind("M_1"=" ",
                   "M_n"=length(M_n),
                   "MN"=length(MN),
                   "N_n"=length(N_n),
                   "N_1"=" ")

FstO.con <- cbind(length(M_1),
                  length(M_n.contigs),
                  paste("mira=", length(MN.mira), "/",
                        "Newbler=", length(MN.newbler), sep=""),
                  length(N_n.contigs),
                  length(N_1))

reads <- cbind(length(M_1.reads),
                 length(M_n.reads),
                 length(MN.reads.inc),
                 unique(length(MN.reads.both)),
                 length(N_n.reads),
                 length(N_1.reads))

reads <- c(reads[c(1,2)],
           paste("one=", reads[3], "/", "both=", reads[4], sep=""),
           reads[c(5,6)])

MNtable <- rbind(SndO.con, FstO.con, reads)
 
row.names(MNtable) <- c("Second order contigs", "First order contigs", "reads")

MNtable.tab <- xtable(MNtable,
                      caption=c("Number of reads, first-order contigs and second-order contigs for different categories of contigs (M\\_1 and N\\_1 = first-order contigs not assembled in second-order assembly, from mira and newbler respectively; M\\_n and N\\_n =  assembled in second-order contigs only with contigs from the same first-order assembly; MN = assembled in second-order contigs with first order contigs from both first order assemblies", "Number of reads, first-order contigs and second-order contigs for different categories of contigs"),
                      label="tab:categ")

align(MNtable.tab) <-  c("p{2.5cm}", "l", "l", "c", "l", "l")

print(MNtable.tab)
@ 

\newpage

\begin{figure}[H]
  \centering
  
<<convenn, echo=FALSE>>=

vennData <- cbind("through Mira"=MERGED$read%in%MN.reads.mira,
                  "split by Newbler"=duplicated(MERGED$read)&
                  (!MERGED$read%in%MN.reads.mira|MERGED$read%in%MN.reads.newbler),
                  "through Newbler"=MERGED$read%in%MN.reads.newbler)
@ 

<<echo=FALSE, fig=TRUE>>=
vennDiagram(vennData, cex=0.9)
@ 

\caption{Classification of reads by the route they followed into the
  final combined assembly (MN category only))}
\label{fig:venncat}
\end{figure}

Additional figure \ref{fig:venncat} gives a more detailed view of the fate of the
reads split by Newbler during first-order assembly. Interestingly most
reads split by Newbler ended up in the high-quality category of the
second order assembly.

\subsection{Contribution of first-order assemblies to second-order contigs}
\label{sec:contr-firs-order}

<<contigdist, echo=FALSE, cache=TRUE>>=
mira.contigs.per.SndO <- by(MERGED, MERGED[,"SndO.MiraContig"], function (x) length(unique(x[!is.na(x$contig.y), ]$contig.y)))
mira.contigs.per.SndO[is.na(mira.contigs.per.SndO)] <- 0
mira.contigs.per.SndO <- as.data.frame(unlist(list(mira.contigs.per.SndO)))

newbler.contigs.per.SndO <- by(MERGED, MERGED[,"SndO.NewblerContig"], function (x) length(unique(x[!is.na(x$contig.x),]$contig.x)))
newbler.contigs.per.SndO[is.na(newbler.contigs.per.SndO)] <- 0
newbler.contigs.per.SndO <- as.data.frame(unlist(list(newbler.contigs.per.SndO)))

contigs.per.SndO <- merge(newbler.contigs.per.SndO, mira.contigs.per.SndO,by="row.names")
names(contigs.per.SndO) <- c("contig", "Newbler_contigs", "Mira_contigs")

@
  
<<readdist, echo=FALSE, cache=TRUE>>=
mira.reads.per.SndO <- by(MERGED, MERGED[,"SndO.MiraContig"], function (x) length(unique(x[!is.na(x$contig.y), ]$read)))
mira.reads.per.SndO[is.na(mira.reads.per.SndO)] <- 0
mira.reads.per.SndO <- as.data.frame(unlist(list(mira.reads.per.SndO)))

newbler.reads.per.SndO <- by(MERGED, MERGED[,"SndO.NewblerContig"], function (x) length(unique(x[!is.na(x$contig.x),]$read)))
newbler.reads.per.SndO[is.na(newbler.reads.per.SndO)] <- 0
newbler.reads.per.SndO <- as.data.frame(unlist(list(newbler.reads.per.SndO)))

reads.per.SndO <- merge(newbler.reads.per.SndO, mira.reads.per.SndO, by="row.names")
names(reads.per.SndO) <- c("contig", "reads_through_Newbler", "reads_through_Mira")

contig.df <- merge(as.data.frame(contigs), reads.per.SndO, by.x="row.names", by.y="contig", all=TRUE)
names(contig.df)[1:2] <- c("contig", "seq")
contig.df <- merge(contig.df, contigs.per.SndO, all=TRUE)

categories <- list(MN=MN, M_n=M_n, N_n=N_n, N_1=N_1, M_1=M_1)
categories <- melt(categories)
names(categories) <- c("contig", "category")
contig.df <- merge(contig.df, categories, all.x=TRUE)
        
contig.df$Newbler_contigs[is.na(contig.df$Newbler_contigs)] <-
ifelse(grepl("tig", contig.df$contig[is.na(contig.df$Newbler_contigs)]),
1, 0)

contig.df$Mira_contigs[is.na(contig.df$Mira_contigs)] <-
ifelse(grepl("Acrassus", contig.df$contig[is.na(contig.df$Mira_contigs)]),
1, 0)

contig.df$reads_through_Newbler[contig.df$Newbler_contigs==0] <- 0
contig.df$reads_through_Mira[contig.df$Mira_contigs==0] <- 0

contig.df$reads_through_Mira[is.na(contig.df$reads_through_Mira)] <-
sapply(contig.df[is.na(contig.df$reads_through_Mira),"contig"],
       function(x) {nrow(MIR[MIR$contig==x,])})

contig.df$reads_through_Newbler[is.na(contig.df$reads_through_Newbler)] <-
sapply(contig.df[is.na(contig.df$reads_through_Newbler),"contig"],
       function(x) {nrow(N25[N25$contig==x,])})

@

Examining the contributions of contigs from each of the assemblies to
one second-order contig in additional figure \ref{fig:rcp}a it becomes
clear that the Mira assembly had many redundant contigs. The reads
contributing to these were assembled into the same contig by Newbler
and finally also into one second-order contig by Cap3.

<<readconplot, echo=FALSE>>=

c.y.num <- c(5, 50, 250, 500)

r.y.num <- c(50, 500, 2500, 5000)
r.x.num <- c(50, 500, 2500, 5000)

c.p.SndO.plot <- ggplot(contig.df,
                        aes(x=Newbler_contigs, y=Mira_contigs)) +
        geom_jitter(size=1) + 
        scale_x_log10("number of newbler contigs") +
        scale_y_log10("number of mira contigs", breaks=c.y.num, labels=c.y.num) +
        theme_bw()

r.p.SndO.plot <- ggplot(contig.df,
                        aes(x=reads_through_Newbler, y=reads_through_Mira)) +
       geom_point(size=1) +
       scale_x_log10("reads through newber", breaks=r.x.num, labels=r.x.num) +
       scale_y_log10("reads through mira", breaks=r.y.num, labels=r.y.num) +
       theme_bw()
@ 

\begin{figure}[H]
  \centering

<<echo=FALSE, fig=TRUE>>=
grid.newpage()
pushViewport(viewport(layout = grid.layout(2, 1)))
vplayout <- function(x, y)
    viewport(layout.pos.row = x, layout.pos.col = y)

# Make each plot, in the correct location
print(c.p.SndO.plot, vp = vplayout(1, 1 ))
print(r.p.SndO.plot, vp = vplayout(2, 1 ))

grid.text("a",x=unit(0.01,"npc"),y=unit(0.9,"npc")) 
grid.text("b",x=unit(0.01,"npc"),y=unit(0.1,"npc")) 

@ 


\caption[Contig and read contribution to second-order contigs.]{
  Contig and read contribution to second-order contigs. (a) Number of
  first-order contigs from both first-order assemblies for each second
  order contig. (b) Number of reads through Newbler and Mira for each
  second-order contig.}
\label{fig:rcp}
  
\end{figure}


A different picture emerges from examination of the contribution of
reads through each of the first-order assemblies (additional figure
\ref{fig:rcp}b).  Here, for most second-order contigs, many more reads
are contributed through Newbler contigs. This is because Newbler has
more reads summed over all contigs, due to the duplication resulting
from splitting of reads.

\newpage

\subsection{Evaluation of the assemblies}
\label{sec:eval-three-assembl}

<<sujeval, echo=FALSE, cache=TRUE>>=

covred.common.blast <- function(blastpath, dbpath){

blast <- read.delim(blastpath, header=FALSE)
blast <- blast[!duplicated(blast$V1),]

BL <- list()
BL[["MN"]] <- blast[blast$V1%in%MN,]
BL[["MN+N_x"]] <- rbind(BL[["MN"]],
                        blast[blast$V1%in%c(N_1,N_n),])
BL[["MN+M_x"]] <- rbind(BL[["MN"]],
                      blast[blast$V1%in%c(M_1, M_n),])
BL[["MN+S"]] <- rbind(BL[["MN"]],
                      blast[blast$V1%in%frass,])
BL[["MN+N_x+S"]] <- rbind(BL[["MN+S"]],
                          blast[blast$V1%in%c(N_1, N_n),])
BL[["MN+M_x+S"]] <- rbind(BL[["MN+S"]],
                          blast[blast$V1%in%c(M_1, M_n),])
BL[["MN+M_x+N_x+S"]] <- blast[blast$V1%in%names(contigs)|
                        blast$V1%in%frass,]
BL[["FU"]] <- blast[blast$V1%in%names(contigs)|
                        blast$V1%in%super.frass,]
BL[["N"]] <- blast[blast$V1%in%Newblercontig.names,]
BL[["N+S"]] <- rbind(BL[["N"]], 
                     blast[blast$V1%in%NewblerSing,])
BL[["N+rS"]] <- rbind(BL[["N"]],
                      blast[blast$V1%in%wrongNewblerSing,])
BL[["M"]] <- blast[blast$V1%in%Miracontig.names,]
BL[["M+S"]] <- rbind(BL[["M"]],
                     blast[blast$V1%in%MiraSing,])

CR <- list()
for (w in names(BL)){
  write.table(BL[[w]],
  "/home/ele/Data/454/assemblies/blasts/tmp",
  col.names=FALSE, row.names=FALSE, quote=FALSE, sep="\t")
  command <- paste("/home/ele/genepool/user/sujai/blast_mask.pl -d",
 dbpath,
 "-redundancy /home/ele/Data/454/assemblies/blasts/tmp 2>&1 1>/dev/null")
   CR[[w]] <- read.delim(pipe(command),
   header=FALSE)
  unlink("/home/ele/Data/454/assemblies/blasts/tmp")
  }
CR <- melt(CR, id.vars=c("V1", "V2", "V3","V4","V5"))
}

Bm.all <- covred.common.blast("/home/ele/Data/454/assemblies/blasts/ALL.fasta_vs_Bm.blt", "/drobo/db/blastdb/uniref100/uniref100_bm.fasta")
Bm.all <- cbind(Bm.all, db="B. malayi")

Ce.all <- covred.common.blast("/home/ele/Data/454/assemblies/blasts/ALL.fasta_vs_Ce.blt", "/drobo/db/blastdb/wormpep220/wormpep220.fasta")
Ce.all <- cbind(Ce.all, db="C. elegans")

ALL <- rbind(Ce.all, Bm.all)
names(ALL)[3:5] <- c("covered", "uncovered", "CovRed")
A <- ALL[,c(3:7)]

suj.summary <- function (x){
  w <- sum(x[,1])/sum(c(x[,1], x[,2]))*100
  y <- nrow(x[x[,1]>0,])/nrow(x)*100
  y80 <- nrow(x[x[,1]>(x[,1]+x[,2])*0.8,])/nrow(x)*100
  z <- sum(x[x[,1]>0,3])
  c("base_cov"=w, "prot_cov" =y, "prot_cov80p" =y80,  sum.CovRed=z)
}
suj.sum <- do.call("rbind", by(A, as.factor(A$db):as.factor(A$L1), suj.summary))
suj.sum <- as.data.frame(suj.sum)
suj.sum$species <- gsub(":.*", "", row.names(suj.sum))
suj.sum$assembly <- gsub(".*:", "", row.names(suj.sum))

frass.nB <- sum(nchar(frass.fasta))
super.frass.nb <- (sum(nchar(super.frass.fasta)))
        
bases <- vector()
bases["MN"] <- sum(nchar(contigs[names(contigs)%in%MN]))
bases["MN+S"] <- bases["MN"]+frass.nB
bases["MN+M_x"] <- bases["MN"] + sum(nchar(contigs[names(contigs)%in%c(N_n, N_1)]))
bases["MN+N_x"] <- bases["MN"] + sum(nchar(contigs[names(contigs)%in%c(M_n, M_1)]))
bases["MN+M_x+S"] <- bases["MN+S"] + sum(nchar(contigs[names(contigs)%in%c(N_n, N_1)]))
bases["MN+N_x+S"] <- bases["MN+S"] + sum(nchar(contigs[names(contigs)%in%c(M_n, M_1)]))
bases["MN+M_x+N_x+S"] <- sum(frass.nB, sum(nchar(contigs)))
bases["FU"] <- sum(super.frass.nb, sum(nchar(contigs)))
bases["N"] <- sum(nchar(CNewbler))
bases["N+S"] <- bases["N"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%NewblerSing]))
bases["N+rS"] <- bases["N"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%wrongNewblerSing]))
bases["M"] <- sum(nchar(CMira))
bases["M+S"] <- bases["M"] + sum(nchar(trimmed.fasta[names(trimmed.fasta)%in%NewblerSing]))

suj.sum <- merge(suj.sum, as.data.frame(bases), by.x="assembly", by.y="row.names")

text.base <- ggplot(suj.sum, aes(x=bases, y=base_cov, label=assembly)) +
             geom_point(size=3) +
             geom_text(color="red", angle = 315, size=2.6, fontface="bold") +
             facet_grid(species ~ ., scales="free_y") +
             scale_y_continuous("percent database-bases covered") +
             scale_x_continuous("bases in assembly") +
             theme_bw() +
             opts(strip.text.y = theme_text(face="italic", angle=90))

text.prot <- ggplot(suj.sum, aes(x=bases, y=prot_cov, label=assembly)) +
             geom_point(size=3) +
             geom_text(color="red", angle = 315, size=2.6, fontface="bold") +
             facet_grid(species ~ ., scales="free_y") +
             scale_y_continuous("percent database-proteins hit") +
             scale_x_continuous("bases in assembly")+
             theme_bw() +
             opts(strip.text.y = theme_text(face="italic", angle=90))

text.prot80 <- ggplot(suj.sum, aes(x=bases, y=prot_cov80p, label=assembly)) +
               geom_point(size=3) +
               geom_text(color="red", angle = 12, size=2.3, fontface="bold") +
               facet_grid(species ~., scales="free_y") +
               scale_y_continuous("percent database-proteins covered > 80% length") +
               scale_x_continuous("bases in assembly") +
               theme_bw() +
               opts(strip.text.y = theme_text(face="italic", angle=90))

bm.covred <- read.delim("/home/ele/Data/454/assemblies/blasts/Bm_vs_Ce_blastmask_sujai.out", header=FALSE, sep="\t")[,c(3:5)]
names(bm.covred) <- c("covered", "uncovered", "CovRed")

bm.ce.sum <- suj.summary(bm.covred)
@

To further compare assemblies (Mira or Newbler first-order assemblies
including or excluding their singletons) and the second-order assembly
(including different contig categories and singletons) we evaluated
the number of bases or proteins their contigs and singletons
(partially) cover in the related model nematodes,
\textit{Caenorhabditis elegans} and \textit{Brugia malayi}. For this
purpose we used BLAST (blastx E-value cut-off 1e-5) and a custom perl
script provided by S. Kumar (mask\_blast.pl available from
github.com/sujaikumar/assemblage).

In addition, the span of an assembly can give an indication of
redundancy or artificially assembled data. If span increases without
reference coverage, the dataset is likely to contain more redundant or
artificial information, and a more parsimonious assembly should be
preferred. The coverage for the two reference species was plotted
against the size of the assembly dataset to estimate the completeness
conditional on the size of the assembly (additional figures
\ref{fig:basecov}, \ref{fig:protcov}, \ref{fig:prot80cov}).

From the assemblies excluding singletons (in the lower left corners of
additional figures \ref{fig:basecov}, \ref{fig:protcov} and
\ref{fig:prot80cov}; with lower size and database coverage) the highly
reliable second order assembly contigs produced the highest per-base
coverage in both reference species, with the Newbler assembly second
and Mira producing the lowest reference coverage. When the contigs
considered lower quality (i.e. supported by only one assembler) were
added to the second-order assembly, reference coverage increased
moderately.

A comparison of the addition of only Newbler's reported singletons and
the addition of all singletons to the Newbler assembly showed that the
reported singletons increased reference coverage to the same extent as
all singletons, while the non-reported singletons only increased the
size of the assembly. It can be concluded that the latter contain very
little additional biological information and are likely to include
only error-prone or variant reads.

The second-order assembly including the intersection of first-order
singletons had similar reference coverage metrics to the Newbler
assembly, but was larger in size. Adding the less reliable set of
one-assembler supported second-order contigs the assembly covered the
most bases in both references. When the intersection of the Newbler
``reported singletons'' and Mira singletons was added a parsimonious
assembly with high reference coverage (termed fullest assembly; and
labeled FU in additional figures \ref{fig:basecov}, \ref{fig:protcov}
and \ref{fig:prot80cov}) was obtained.

\begin{sidewaysfigure}

<<echo=FALSE, fig=true>>=

print(text.base)

@ 
\caption[Span and reference transcriptome coverage (in bases)]{Span
  and reference transcriptome coverage (in bases) for different
  assemblies and assembly-combinations. M = Mira; N = Newbler; $M+S$ =
  Mira + singletons; $N+S$ = Newbler plus singletons; $N+Sr$ = Newbler
  plus singletons reported in readstatus.txt; MN = second-order
  contigs supported by both first-order; $MN+N\_x$ = second-order MN
  plus contigs only supported by Newbler ($N\_x$ = $N\_n$ and $N\_1$);
  $MN+M\_x$ = same for Mira-first-order-contigs; $MN+M\_x+S$ and
  $MN+N\_x+S$ same with singletons; FU = second-order contigs
  supported by both or one assembler plus the intersection of Newbler
  reported singletons and Mira-singletons = the basis for the
  ``fullest assembly'' used in later analyses.}
\label{fig:basecov}
\end{sidewaysfigure}


\begin{sidewaysfigure}

<<echo=FALSE, fig=true>>=

print(text.prot)

@ 
\caption[Span and reference transcriptome coverage in percent of
proteins hit]{Span and reference transcriptome coverage in percent of
  proteins hit for different assemblies and assembly-combinations. For
  category abrevations see additional figure \ref{fig:basecov}.}
\label{fig:protcov}
\end{sidewaysfigure}

\begin{sidewaysfigure}

<<echo=FALSE, fig=true>>=

print(text.prot80)
## xtable(suj.sum, digits=2, label="tab:suj.sum", caption="bla")
@ 
\caption[Span and reference transcriptome coverage in percent of
proteins coverd to at least 80\% of their length]{Span and reference
  transcriptome coverage in percent of proteins coverd to at least
  80\% of their length for different assemblies and assembly
  combinations. For category abrevations see additional figure
  \ref{fig:basecov}.}
\label{fig:prot80cov}
\end{sidewaysfigure}

When database proteins covered for at least 80\% of their length are
considered (additonal figure \ref{fig:prot80cov}) the second-order
assembly was superior: Both ex- and in-cluding singletons the
second-order assembly outperformed the first-order
assemblies. Moderate gains in reference coverage were made again for
the addition of dubious single assembler supported second-order
contigs. 

Given this evaluation we defined the ``minimal adequate assembly'' as
the subset of contigs of the second-order assembly supported by both
assemblers (labeled MN above). Given the performance of the singletons
Newbler reported, we defined the ``fullest assembly'' as all
second-order contigs (including those supported by only one assembler)
plus the intersection of reported Newbler singletons and Mira
singletons.

The proportion of proteins covered in \textit{C. elegans} by
\textit{B. malayi} coding sequences was with
\Sexpr{round(bm.ce.sum["prot_cov"],2)}\% simimlar to our estimate for
the fullest (FU) assembly. The proportion of bases
(\Sexpr{round(bm.ce.sum["base_cov"],2)}\%) and of proteins coverd to
at least 80\% of their length
(\Sexpr{round(bm.ce.sum["prot_cov80p"],2)}\%) was however higher for
the coding sequences from \textit{B. malayi}.

\subsection{Measurments on second-order assembly}

Based on the tracking of reads through the assembly process, we
calculated the following statistics for each contig in the
second-order assembly.

\begin{itemize}
\item number of Mira and Newbler first-order contigs
\item number of reads in each contributing Mira contig and Newbler
  contig
\item number of reads split by Newbler in first-order assembly
\item number of read-split events in the first-order assembly (the sum
  of reads multiplied by number of contigs a read has been split into)
\item maximal number of first-order contigs a read in the contig has
  been split into during Newbler assembly
\item the number of reads same-read-paires from the Newbler and Mira
  first order-assembly merged in a second order contig
\item cluster-id of the contig: the cluster to which the contig
  belongs (contigs ``connected'' by sharing reads are placed in one
  cluster; similar to the graph clustering reported in
  \cite{pmid21138572}).
\item number of other second-order contigs containing the same read
  i.e. the size of the cluster
\end{itemize}

<<echo=FALSE, cache=TRUE>>=
##  number of reads being split in first order assembly
num.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) nrow(x[x$new.split>1, ]))))
## The NA's, where there is no newbler contig in the SnO.contig can be replace by 1
num.new.split[is.na(num.new.split)] <- 0
contig.df <- merge(contig.df, num.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "num.new.split"

sum.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) sum(x$new.split))))
## The NA's, where there is no newbler contig in the SnO.contig can be replace by 1
sum.new.split[is.na(sum.new.split)] <- 0
contig.df <- merge(contig.df, sum.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "sum.new.split"

## per SndOcontig maximal number of N25 contigs read is split into
max.new.split <- do.call("rbind",
                     as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                function (x) max(x$new.split))))
## The NA's, where there is no newbler
## contig in the SnO.contig can be replace by 0
max.new.split[is.na(max.new.split)] <- 0
contig.df <- merge(contig.df, max.new.split, by.x="contig", by.y="row.names", all=TRUE)
names(contig.df)[ncol(contig.df)] <- "max.new.split"

## the number of reads merged back into one second order contig
## num.SndO.merge <- do.call("rbind",
##                           as.list(by(MERGED, MERGED$SndO.NewblerContig,
##                                      function (x) {
##                                        nrow(x[x$SndO.MiraContig!=x$SndO.NewblerContig
##                                               & !is.na(x$SndO.MiraContig)
##                                               & !is.na(x$SndO.NewblerContig),])
##                                      })))
## num.SndO.merge[is.na(num.SndO.merge)] <- 0
## contig.df <- merge(contig.df, num.SndO.merge, by.x="contig", by.y="row.names", all.x=TRUE)
## names(contig.df)[ncol(contig.df)] <- "num.SndO.merge"

num.SndO.pair <- do.call("rbind",
                          as.list(by(MERGED, MERGED$SndO.NewblerContig,
                                     function (x) {
                                       nrow(x[x$SndO.MiraContig==x$SndO.NewblerContig
                                              & !is.na(x$SndO.MiraContig)
                                              & !is.na(x$SndO.NewblerContig),])
                                     })))
num.SndO.pair[is.na(num.SndO.pair)] <- 0
contig.df <- merge(contig.df, num.SndO.pair, by.x="contig", by.y="row.names", all.x=TRUE)
names(contig.df)[ncol(contig.df)] <- "num.SndO.pair"
@ 

<<cluster, echo=FALSE, cache=TRUE>>=
SndO <- cbind(as.character(MERGED$SndO.NewblerContig), as.character(MERGED$SndO.MiraContig))
SndO <- SndO[SndO[,1]!=SndO[,2] & !is.na(SndO[,1]) & !is.na(SndO[,2]),]
a <- apply(SndO, 1 , list)

add.up.clusters <- function (clustlist){
  clustlist <- unique(clustlist)
  clus <- list()
  for(k in 1:length(clustlist)){
    e <- sapply(1:length(clustlist),function (i) {
      any(unlist(clustlist[k]) %in% unlist(clustlist[i]))
    })
    clus[[k]] <- unique(unlist(clustlist[e]))
  }
  return(unique(clus))
}

## make it work recursively to fully collapse clusters
recursive.cluster <- function(clusterlist){
  res <- list(NA, clusterlist)
  while(length(res[[length(res)]])!=length(res[[length(res)-1]])){
    res[[length(res)+1]] <- add.up.clusters(res[[length(res)]])
  }
  return(res[[length(res)]])
}

SndO.clusters <- recursive.cluster(a)


names(SndO.clusters) <- paste("CL", 1:length(SndO.clusters), sep="")

SndO.cluster.id <- melt(SndO.clusters)
names(SndO.cluster.id) <- c("contig", "cluster.id")
                                    
write(unlist(lapply(SndO.clusters, paste, collapse=" ")),
      file="/home/ele/thesis/454/SndO.clusters")
                                    
SndO.cluster.size <- as.data.frame(do.call("rbind",
                                           lapply(SndO.clusters,
                                                  function (x)
                                                  cbind(contig=x, cluster.size=length(x)))))
SndO.cluster.size$cluster.size <- as.numeric(as.character(SndO.cluster.size$cluster.size))

contig.df <- merge(contig.df, SndO.cluster.id,  all=TRUE)
contig.df <- merge(contig.df, SndO.cluster.size,  all=TRUE)

contig.df$cluster.size <- ifelse(is.na(contig.df$cluster.size), 1, contig.df$cluster.size)

super.frass.frame <- as.data.frame(super.frass.fasta)
super.frass.frame$contig <- row.names(super.frass.frame)
super.frass.frame <- super.frass.frame[,c(2,1)]
super.frass.frame[, 3:ncol(contig.df)] <- 0
names(super.frass.frame) <- names(contig.df)

contig.df <- rbind(contig.df, super.frass.frame)

#contig.df$num.SndO.merge[is.na(contig.df$num.SndO.merge)] <- 0
contig.df$num.SndO.pair[is.na(contig.df$num.SndO.pair)] <- 0
contig.df$num.new.split[is.na(contig.df$num.new.split)] <- 0
contig.df$sum.new.split[is.na(contig.df$sum.new.split)] <- 0
contig.df$max.new.split[is.na(contig.df$max.new.split)] <- 0
contig.df$cluster.id[is.na(contig.df$cluster.id)] <- 0
@ 

\subsubsection{Contig coverage}

\SweaveInput{../Supporting_information/pileup_read.Rnw}

As well defined coverage-information was not readily avaiable from the
output of this combined assembly aproach (although we followed
individual reads through the process) we inferred coverage by mapping
the reads used for assembly against the fullest assembly using ssaha2
\cite{pmid11591649} with parameters (-kmer 13 -skip 3 -seeds 6 -score
100 -cmatch 10 -ckmer 6 -output sam -best 1). This read mapping was
summarised by:

\begin{itemize}
\item mean per base coverage
\item mean unique per base coverage
\end{itemize}

The ratio of mean per base coverage and unique per base coverage (the
standard for assessing coverage) can be used to assess the redundancy
of a contig.

\subsubsection{Example use of the contig-measurements}

Based on these measurements the generation of a given contig by the
assembly process can be reconstructed. Additional table
\ref{tab:ex-me} gives an excerpt of the contig-measurements reported
in additional file A.crassus\_transcriptome\_contig\_data.csv. The
example contigs are all from large contig clusters (cluster.size),
where interpretation of the assembly history is more complex:

<<echo=FALSE, results=tex>>=

show <- head(contig.df[contig.df$cluster.size>12,c(1, 3:15) ], n=2)
show <- rbind(show,
              head(contig.df[contig.df$cluster.size>1 &
                             contig.df$category=="M_n" ,c(1, 3:15) ], n=1))
show <- rbind(show,
              head(contig.df[contig.df$cluster.size>1 &
                             contig.df$category=="N_n" ,c(1, 3:15) ], n=1))

row.names(show) <- show$contig
show$contig <- NULL
xtable(t(show), caption="example table for assembly-measurements on contigs (as given in
                         A.crassus\\_transcriptome\\_contig\\_data.csv)", label="tab:ex-me")
@ 

\textbf{Contig1047} is from the well trusted MN category of
contigs. It consists of only one contig from each first-order assembly
(newbler\_contigs and mira\_contigs), each containing a set of reads
of moderate size: 16 from Newbler (reads\_through\_newbler), and 26
from Mira (reads\_through\_mira). 8 of the 16 reads Newbler used were
also assembled to a differnt Newbler contig (num.new.split). That each
of the 8 reads only appeared in one other Newbler contig is evident as
the number of split events is 16 (sum.new.split) and the maximal
number of splits for one read is 2 (max.new.split). 13 (num.SndO.pair)
same-read-pairs from the two different first-order assemblies were
merged in this second-order contig, leaving 3 (16-13) reads in Newbler
contigs and 13 (26-13) reads in Mira contigs, which all could
potentially have ended up in other contigs. The contig is in a cluster
(CL62), which contains 24 contigs (cluster.size). The complete graph
structure linking these 24 contigs cannot be reconstructed from this
contig summary data. The summary data makes clear the sources of links
for cluster-affiliation: In the case of Contig1047 from 3 and 13
unlinked read-paires from both first-order assemblies and 8 split
reads from Newbler first-order contigs.

A comprehensive interpretation of the other example contigs depicted
is left to the reader. It should just be remarked, that in case of
one-assembler supported contigs, all reads in that contig could
potentially be represented in other contigs, making average
cluster-size in these contigs bigger than in MN category.\\

Interesting measurements calculated for each contig include the
cluster membership and cluster size. Such clusters represent close
paralogs, duplicated genes, isoforms from alternative splicing or
allelic variants. These measurements can be used in later analysis to
e.g. reevaluate the likelihood of misassembly in a given set of
biologically relevant contigs. All gene sets discussed in the main
text were, as a matter of routine, controlled for unusual patterns in
the contig meta-data.
\newpage

\subsection{Finalising the fullest assembly set}
\label{sec:final-full-assembly}

In order to minimize the amount of sequence with artificially inferred
isoform breakpoints we used the unique mapping information described
above to detect contigs and singletons not supported by any
independent raw data (reads). Additional table \ref{tab:cov.ex} gives
a summary of these unsupported data by contig category. For all
downstream analyses we removed all the MN-category contigs and the
contigs (and singletons) from other categories having no unique
coverage.


<<echo=FALSE, results=tex>>=

cov.ex <- do.call("rbind",
                  list(by(contig.df, contig.df$category,
                          function (x) nrow(x[x$coverage==0, ]))))
cov.ex <- rbind(cov.ex, do.call("rbind",
                                list(by(contig.df, contig.df$category,
                                        function (x) nrow(x[x$uniq_coverage==0, ])))))

row.names(cov.ex) <- c("coverage == 0", "unique coverage == 0")
cov.ex <- data.frame(cov.ex)
names(cov.ex)[1] <- "singletons"

cov.ex.tab <- xtable(cov.ex,
                     caption= "number of contigs with a coverage and unique-coverage of zero, inferred from mapping of raw reads, listed by contig-category",
                     label="tab:cov.ex")
print(cov.ex.tab)

contig.df <- contig.df[contig.df$coverage>0, ]
contig.df <- contig.df[contig.df$uniq_coverage>0 | contig.df$category=="MN", ]

## Two last important measurements
contig.df$gc <- get.gc(contig.df$seq)
contig.df$length <- nchar(as.character(contig.df$seq))

@ 

The remaining 40,187 tentative unique genes (TUGs), define the
``fullest assembly''. The MN-category of contigs form the high
credibility assembly (highCA) and the M\_n, N\_n, M\_1, N\_1 and
Newbler's reported singletons are the additional low credibility
assembly (lowCA).

\newpage

\subsection{Scrutinising the GO annotation}
\label{sec:scrut-GO}

GO-annotations based on similarity searches are often considered not
reliable for species diverged from the model-species in which they
were developed. To investigate the validity of GO-terms assigned by
BLAST similarity we compared the annot8r derived terms with
domain-based (Interpro-Scan) annotations. We classified contigs and
their annotations as "in complete agreement" if the lowest level term
(the highest number of terms away from the roots ``biological
process'' or ``molecular function'') was the same for the two methods.
A contig was classified as having a ``more detailed'' annotation if
the respective method yielded an agreeing term at a lower (offspring)
level compared the other. Finally there were contigs for which only
one method yielded an annotation.

This comparison revealed a high agreement between annotation based on
sequence similarity and on domain architecture, where annotations from
both sources were present. Half of our contigs, however, are annotated
based on similarity alone. It can not be excluded that these
annotations have additional bias not observed in contigs with
annotations from both sources. Therefore we did not rely on single
detailed GO assignments, but rather searched for overall patterns
through enrichment analyses. These analyses make it more feasible to
detect a signal at higher levels of annotations, thus alleviating the
quality-problems of more detailed annotations.

\begin{figure}
  \centering
\includegraphics{GO_pie.pdf}
\caption[Agreement of GO-annotation]{Comparing BLAST with domain based
  annotations, contigs were classified being annotated in "complete
  agreement" if one lowest level term was the same for the two
  methods. If a lower level term was derived for any of the methods
  the ``more detailed'' classification was used. Contigs with
  disagreeing annotations were grouped into ``lower level
  disagreement'' or ``first level disagreement'' according annotations
  at the first level below the root term.}
\end{figure}



<<save, echo=FALSE>>=
## save what is needed downstream
fullest.assembly <- c(contigs ,
                      super.frass.fasta)[names(c(contigs, super.frass.fasta))%in%
                                         contig.df$contig] 
save(file="Assembly.Rdata", list=c("contig.df", "con.pile", "con.pile.uniq", "per.con", "per.con.uniq", "raw.fasta", "nBases", "fullest.assembly"))

write.sequence(fullest.assembly, "/home/ele/thesis/454/fullest_assembly.fasta")
save.image(file="Assembly_image.Rdata")
@ 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                  The Bibliography                       %%
%%                                                         %%              
%%  Bmc_article.bst  will be used to                       %%
%%  create a .BBL file for submission, which includes      %%
%%  XML structured for BMC.                                %%
%%                                                         %%
%%                                                         %%
%%  Note that the displayed Bibliography will not          %% 
%%  necessarily be rendered by Latex exactly as specified  %%
%%  in the online Instructions for Authors.                %% 
%%                                                         %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliographystyle{/home/ele/bibtex/bmc_article.bst} % Style BST file
\newpage
\bibliography{/home/ele/bibtex/master.bib} % Bibliography file (usually '*.bib' )

\end{document}
